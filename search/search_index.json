{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Redirecting... If you are not redirected automatically, follow this link to v1/index.md .","title":"Home"},{"location":"v1/","text":"Welcome to DocumentDB \u00b6 DocumentDB is a fully open-source document-oriented database engine, built on PostgreSQL. It supports seamless CRUD operations on BSON data types, full-text search, geospatial queries, and vector embeddings \u2014 all within the robust PostgreSQL ecosystem. Getting Started with DocumentDB \u00b6 A curated collection of guides to help you understand what DocumentDB is, why it matters, and how to get up and running\u2014from initial setup to advanced document operations. Introduction Why DocumentDB? DocumentDB Gateway Prebuild Image Getting Started Usage (CRUD) Collection Management Indexing Aggregation Joins Packaging Data Initialization \ud83d\ude80 Features \u00b6 Native PostgreSQL extension with BSON support Powerful CRUD and indexing capabilities Support for full-text search, geospatial data, and vector workloads Fully open-source under the MIT License On-premises and cloud-ready deployment \ud83e\uddf1 Components \u00b6 pg_documentdb_core \u2013 PostgreSQL extension for BSON type and operations pg_documentdb \u2013 Public API layer enabling document-oriented access pg_documentdb_gw \u2013 Gateway for DocumentDB, providing a MongoDB interface \ud83d\udc33 Quick Start with Docker \u00b6 Prebuild Image For DocumentDB \u00b6 There are prebuild images available for different platforms. You can find the list of prebuild images here . To run the prebuild image, use the following command: # example for Ubuntu 22.04, PostgreSQL 16, amd64 # Choose the image tag according to your configuration docker run -dt mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG16-AMD64-0.103.0 docker exec -it <container-id> bash Prebuild Image For DocumentDB with Gateway \u00b6 To run the prebuild image with the DocumentDB Gateway, use the following command: docker run -dt -p 10260:10260 -e USERNAME=<username> -e PASSWORD=<password> ghcr.io/microsoft/documentdb/documentdb-local:latest mongosh localhost:10260 -u <username> -p <password> \\ --authenticationMechanism SCRAM-SHA-256 \\ --tls \\ --tlsAllowInvalidCertificates Build DocumentDB from Source \u00b6 git clone https://github.com/microsoft/documentdb.git cd documentdb docker build -f .devcontainer/Dockerfile -t documentdb . docker run -v $(pwd):/home/documentdb/code -it documentdb /bin/bash make && sudo make install Community \u00b6 Please refer to page for contributing to our Roadmap list . FerretDB integration allows using DocumentDB as backend engine. Contributors and users can join the DocumentDB Discord channel in the Microsoft OSS server for quick collaboration. How to Contribute \u00b6 To contribute, see these documents: Code of Conduct Security Contributing FAQs \u00b6 Q1. While performing make check if you encounter error FATAL: \"/home/documentdb/code/pg_documentdb_core/src/test/regress/tmp/data\" has wrong ownership ? Please drop the /home/documentdb/code/pg_documentdb_core/src/test/regress/tmp/ directory and rerun the make check . Contributors and users can join the DocumentDB Discord channel in the Microsoft OSS server for quick collaboration. License \u00b6 DocumentDB is licensed under the MIT License. See LICENSE for details. Trademarks \u00b6 This project may use trademarks or logos. Use of Microsoft trademarks must follow Microsoft\u2019s Trademark & Brand Guidelines . Use of third-party marks is subject to their policies.","title":"Get Started"},{"location":"v1/#welcome-to-documentdb","text":"DocumentDB is a fully open-source document-oriented database engine, built on PostgreSQL. It supports seamless CRUD operations on BSON data types, full-text search, geospatial queries, and vector embeddings \u2014 all within the robust PostgreSQL ecosystem.","title":"Welcome to DocumentDB"},{"location":"v1/#getting-started-with-documentdb","text":"A curated collection of guides to help you understand what DocumentDB is, why it matters, and how to get up and running\u2014from initial setup to advanced document operations. Introduction Why DocumentDB? DocumentDB Gateway Prebuild Image Getting Started Usage (CRUD) Collection Management Indexing Aggregation Joins Packaging Data Initialization","title":"Getting Started with DocumentDB"},{"location":"v1/#features","text":"Native PostgreSQL extension with BSON support Powerful CRUD and indexing capabilities Support for full-text search, geospatial data, and vector workloads Fully open-source under the MIT License On-premises and cloud-ready deployment","title":"\ud83d\ude80 Features"},{"location":"v1/#components","text":"pg_documentdb_core \u2013 PostgreSQL extension for BSON type and operations pg_documentdb \u2013 Public API layer enabling document-oriented access pg_documentdb_gw \u2013 Gateway for DocumentDB, providing a MongoDB interface","title":"\ud83e\uddf1 Components"},{"location":"v1/#quick-start-with-docker","text":"","title":"\ud83d\udc33 Quick Start with Docker"},{"location":"v1/#prebuild-image-for-documentdb","text":"There are prebuild images available for different platforms. You can find the list of prebuild images here . To run the prebuild image, use the following command: # example for Ubuntu 22.04, PostgreSQL 16, amd64 # Choose the image tag according to your configuration docker run -dt mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG16-AMD64-0.103.0 docker exec -it <container-id> bash","title":"Prebuild Image For DocumentDB"},{"location":"v1/#prebuild-image-for-documentdb-with-gateway","text":"To run the prebuild image with the DocumentDB Gateway, use the following command: docker run -dt -p 10260:10260 -e USERNAME=<username> -e PASSWORD=<password> ghcr.io/microsoft/documentdb/documentdb-local:latest mongosh localhost:10260 -u <username> -p <password> \\ --authenticationMechanism SCRAM-SHA-256 \\ --tls \\ --tlsAllowInvalidCertificates","title":"Prebuild Image For DocumentDB with Gateway"},{"location":"v1/#build-documentdb-from-source","text":"git clone https://github.com/microsoft/documentdb.git cd documentdb docker build -f .devcontainer/Dockerfile -t documentdb . docker run -v $(pwd):/home/documentdb/code -it documentdb /bin/bash make && sudo make install","title":"Build DocumentDB from Source"},{"location":"v1/#community","text":"Please refer to page for contributing to our Roadmap list . FerretDB integration allows using DocumentDB as backend engine. Contributors and users can join the DocumentDB Discord channel in the Microsoft OSS server for quick collaboration.","title":"Community"},{"location":"v1/#how-to-contribute","text":"To contribute, see these documents: Code of Conduct Security Contributing","title":"How to Contribute"},{"location":"v1/#faqs","text":"Q1. While performing make check if you encounter error FATAL: \"/home/documentdb/code/pg_documentdb_core/src/test/regress/tmp/data\" has wrong ownership ? Please drop the /home/documentdb/code/pg_documentdb_core/src/test/regress/tmp/ directory and rerun the make check . Contributors and users can join the DocumentDB Discord channel in the Microsoft OSS server for quick collaboration.","title":"FAQs"},{"location":"v1/#license","text":"DocumentDB is licensed under the MIT License. See LICENSE for details.","title":"License"},{"location":"v1/#trademarks","text":"This project may use trademarks or logos. Use of Microsoft trademarks must follow Microsoft\u2019s Trademark & Brand Guidelines . Use of third-party marks is subject to their policies.","title":"Trademarks"},{"location":"v1/aggregation/","text":"Perform aggregations Group by \u00b6 DocumentDB provides the documentdb_api.aggregate_cursor_first_page function, for performing aggregations over the document store. The example projects an aggregation on number of patients registered over the years. SELECT cursorpage FROM documentdb_api.aggregate_cursor_first_page('documentdb', '{ \"aggregate\": \"patient\", \"pipeline\": [ { \"$group\": { \"_id\": \"$registration_year\", \"count_patients\": { \"$count\": {} } } } ] , \"cursor\": { \"batchSize\": 3 } }'); We can perform more complex operations, listing below a few more usage examples. The example demonstrates an aggregation on patients, categorizing them into buckets defined by registration_year boundaries. SELECT cursorpage FROM documentdb_api.aggregate_cursor_first_page('documentdb', '{ \"aggregate\": \"patient\", \"pipeline\": [ { \"$bucket\": { \"groupBy\": \"$registration_year\", \"boundaries\": [\"2022\",\"2023\",\"2024\"], \"default\": \"unknown\" } } ], \"cursor\": { \"batchSize\": 3 } }'); This query performs an aggregation on the patient collection to group documents by registration_year . It collects unique patient conditions for each registration year using the $addToSet operator. SELECT cursorpage FROM documentdb_api.aggregate_cursor_first_page('documentdb', '{ \"aggregate\": \"patient\", \"pipeline\": [ { \"$group\": { \"_id\": \"$registration_year\", \"conditions\": { \"$addToSet\": { \"conditions\" : \"$conditions\" } } } } ], \"cursor\": { \"batchSize\": 3 } }');","title":"Aggregation"},{"location":"v1/aggregation/#perform-aggregations-group-by","text":"DocumentDB provides the documentdb_api.aggregate_cursor_first_page function, for performing aggregations over the document store. The example projects an aggregation on number of patients registered over the years. SELECT cursorpage FROM documentdb_api.aggregate_cursor_first_page('documentdb', '{ \"aggregate\": \"patient\", \"pipeline\": [ { \"$group\": { \"_id\": \"$registration_year\", \"count_patients\": { \"$count\": {} } } } ] , \"cursor\": { \"batchSize\": 3 } }'); We can perform more complex operations, listing below a few more usage examples. The example demonstrates an aggregation on patients, categorizing them into buckets defined by registration_year boundaries. SELECT cursorpage FROM documentdb_api.aggregate_cursor_first_page('documentdb', '{ \"aggregate\": \"patient\", \"pipeline\": [ { \"$bucket\": { \"groupBy\": \"$registration_year\", \"boundaries\": [\"2022\",\"2023\",\"2024\"], \"default\": \"unknown\" } } ], \"cursor\": { \"batchSize\": 3 } }'); This query performs an aggregation on the patient collection to group documents by registration_year . It collects unique patient conditions for each registration year using the $addToSet operator. SELECT cursorpage FROM documentdb_api.aggregate_cursor_first_page('documentdb', '{ \"aggregate\": \"patient\", \"pipeline\": [ { \"$group\": { \"_id\": \"$registration_year\", \"conditions\": { \"$addToSet\": { \"conditions\" : \"$conditions\" } } } } ], \"cursor\": { \"batchSize\": 3 } }');","title":"Perform aggregations Group by"},{"location":"v1/building/","text":"Building and Running DocumentDB from Source \u00b6 If you want to build and run DocumentDB from source (instead of using Docker), follow these steps. This guide is designed for beginners and works best on Ubuntu/Debian. For other operating systems, package names may differ. Prerequisites \u00b6 Recommended use the provided devcontainer for VSCode which contains all the dependencies pre-installed. Or install the required dependencies: sudo apt update sudo apt install build-essential libbson-dev postgresql-server-dev-all pkg-config rustc cargo Step 1: Build PostgreSQL Extensions \u00b6 sudo make install Step 2: Build the Gateway \u00b6 scripts/build_and_install_with_pgrx.sh -i -d pg_documentdb_gw_host/ Step 3: Start PostgreSQL and the Gateway \u00b6 scripts/start_oss_server.sh -c -g Step 4: Connect and Test \u00b6 Using a MongoDB Client \u00b6 mongosh --host localhost --port 10260 --tls --tlsAllowInvalidCertificates -u docdb_user -p Admin100 Try basic MongoDB commands to verify everything works. Using PostgreSQL shell \u00b6 psql -p 9712 -d postgres Need Help? \u00b6 Join our Discord See docs for more details","title":"Building and Running DocumentDB from Source"},{"location":"v1/building/#building-and-running-documentdb-from-source","text":"If you want to build and run DocumentDB from source (instead of using Docker), follow these steps. This guide is designed for beginners and works best on Ubuntu/Debian. For other operating systems, package names may differ.","title":"Building and Running DocumentDB from Source"},{"location":"v1/building/#prerequisites","text":"Recommended use the provided devcontainer for VSCode which contains all the dependencies pre-installed. Or install the required dependencies: sudo apt update sudo apt install build-essential libbson-dev postgresql-server-dev-all pkg-config rustc cargo","title":"Prerequisites"},{"location":"v1/building/#step-1-build-postgresql-extensions","text":"sudo make install","title":"Step 1: Build PostgreSQL Extensions"},{"location":"v1/building/#step-2-build-the-gateway","text":"scripts/build_and_install_with_pgrx.sh -i -d pg_documentdb_gw_host/","title":"Step 2: Build the Gateway"},{"location":"v1/building/#step-3-start-postgresql-and-the-gateway","text":"scripts/start_oss_server.sh -c -g","title":"Step 3: Start PostgreSQL and the Gateway"},{"location":"v1/building/#step-4-connect-and-test","text":"","title":"Step 4: Connect and Test"},{"location":"v1/building/#using-a-mongodb-client","text":"mongosh --host localhost --port 10260 --tls --tlsAllowInvalidCertificates -u docdb_user -p Admin100 Try basic MongoDB commands to verify everything works.","title":"Using a MongoDB Client"},{"location":"v1/building/#using-postgresql-shell","text":"psql -p 9712 -d postgres","title":"Using PostgreSQL shell"},{"location":"v1/building/#need-help","text":"Join our Discord See docs for more details","title":"Need Help?"},{"location":"v1/collection-management/","text":"Collection management \u00b6 We can review for the available collections and databases by querying documentdb_api.list_collections_cursor_first_page . SELECT * FROM documentdb_api.list_collections_cursor_first_page('documentdb', '{ \"listCollections\": 1 }'); documentdb_api.list_indexes_cursor_first_page allows reviewing for the existing indexes on a collection. We can find collection_id from documentdb_api.list_collections_cursor_first_page . SELECT documentdb_api.list_indexes_cursor_first_page('documentdb','{\"listIndexes\": \"patient\"}'); ttl indexes by default gets scheduled through the pg_cron scheduler, which could be reviewed by querying the cron.job table. select * from cron.job;","title":"Collection management"},{"location":"v1/collection-management/#collection-management","text":"We can review for the available collections and databases by querying documentdb_api.list_collections_cursor_first_page . SELECT * FROM documentdb_api.list_collections_cursor_first_page('documentdb', '{ \"listCollections\": 1 }'); documentdb_api.list_indexes_cursor_first_page allows reviewing for the existing indexes on a collection. We can find collection_id from documentdb_api.list_collections_cursor_first_page . SELECT documentdb_api.list_indexes_cursor_first_page('documentdb','{\"listIndexes\": \"patient\"}'); ttl indexes by default gets scheduled through the pg_cron scheduler, which could be reviewed by querying the cron.job table. select * from cron.job;","title":"Collection management"},{"location":"v1/data-initialization/","text":"Data Initialization Support \u00b6 DocumentDB supports two initialization modes when the emulator container starts: Built-in sample data for quick exploration (enabled by default) Custom JavaScript initialization scripts supplied by the user Environment Variables \u00b6 The entrypoint honors the following environment variables: INIT_DATA_PATH : Directory containing .js initialization files (default: /init_doc_db.d ). SKIP_INIT_DATA : Set to true to skip loading built-in sample data (default: false ). Note: When custom initialization is requested with --init-data-path , the entrypoint internally sets SKIP_INIT_DATA=true so that only the provided scripts run. Command Line Options \u00b6 --init-data-path [PATH] : Execute all .js files in the specified directory (alphabetical order) using mongosh . --skip-init-data : Skip loading the built-in sample collections. If no option is supplied, the emulator starts with the built-in sample data. Usage Examples \u00b6 Default startup (built-in sample data) \u00b6 docker run -p 10260:10260 -p 9712:9712 \\ --password mypassword \\ documentdb/local Skip sample data entirely \u00b6 docker run -p 10260:10260 -p 9712:9712 \\ --skip-init-data \\ --password mypassword \\ documentdb/local Use custom initialization scripts \u00b6 docker run -p 10260:10260 -p 9712:9712 \\ -v /path/to/your/init/scripts:/init_doc_db.d \\ --init-data-path /init_doc_db.d \\ --password mypassword \\ documentdb/local Configure via environment variables \u00b6 docker run -p 10260:10260 -p 9712:9712 \\ -e INIT_DATA_PATH=/custom/init/path \\ -e SKIP_INIT_DATA=true \\ -e PASSWORD=mypassword \\ -v /path/to/your/init/scripts:/custom/init/path \\ documentdb/local Built-in Sample Data \u00b6 Unless --skip-init-data (or SKIP_INIT_DATA=true ) is supplied, the following collections are created in the sampledb database: - users (5 sample users) - products (5 sample products) - orders (4 sample orders) - analytics (sample metrics and activity data) Security Note \u00b6 Built-in sample data is intended for evaluation scenarios. Disable it via --skip-init-data / SKIP_INIT_DATA=true and provide vetted scripts through INIT_DATA_PATH for production workloads.","title":"Data Initialization Support"},{"location":"v1/data-initialization/#data-initialization-support","text":"DocumentDB supports two initialization modes when the emulator container starts: Built-in sample data for quick exploration (enabled by default) Custom JavaScript initialization scripts supplied by the user","title":"Data Initialization Support"},{"location":"v1/data-initialization/#environment-variables","text":"The entrypoint honors the following environment variables: INIT_DATA_PATH : Directory containing .js initialization files (default: /init_doc_db.d ). SKIP_INIT_DATA : Set to true to skip loading built-in sample data (default: false ). Note: When custom initialization is requested with --init-data-path , the entrypoint internally sets SKIP_INIT_DATA=true so that only the provided scripts run.","title":"Environment Variables"},{"location":"v1/data-initialization/#command-line-options","text":"--init-data-path [PATH] : Execute all .js files in the specified directory (alphabetical order) using mongosh . --skip-init-data : Skip loading the built-in sample collections. If no option is supplied, the emulator starts with the built-in sample data.","title":"Command Line Options"},{"location":"v1/data-initialization/#usage-examples","text":"","title":"Usage Examples"},{"location":"v1/data-initialization/#default-startup-built-in-sample-data","text":"docker run -p 10260:10260 -p 9712:9712 \\ --password mypassword \\ documentdb/local","title":"Default startup (built-in sample data)"},{"location":"v1/data-initialization/#skip-sample-data-entirely","text":"docker run -p 10260:10260 -p 9712:9712 \\ --skip-init-data \\ --password mypassword \\ documentdb/local","title":"Skip sample data entirely"},{"location":"v1/data-initialization/#use-custom-initialization-scripts","text":"docker run -p 10260:10260 -p 9712:9712 \\ -v /path/to/your/init/scripts:/init_doc_db.d \\ --init-data-path /init_doc_db.d \\ --password mypassword \\ documentdb/local","title":"Use custom initialization scripts"},{"location":"v1/data-initialization/#configure-via-environment-variables","text":"docker run -p 10260:10260 -p 9712:9712 \\ -e INIT_DATA_PATH=/custom/init/path \\ -e SKIP_INIT_DATA=true \\ -e PASSWORD=mypassword \\ -v /path/to/your/init/scripts:/custom/init/path \\ documentdb/local","title":"Configure via environment variables"},{"location":"v1/data-initialization/#built-in-sample-data","text":"Unless --skip-init-data (or SKIP_INIT_DATA=true ) is supplied, the following collections are created in the sampledb database: - users (5 sample users) - products (5 sample products) - orders (4 sample orders) - analytics (sample metrics and activity data)","title":"Built-in Sample Data"},{"location":"v1/data-initialization/#security-note","text":"Built-in sample data is intended for evaluation scenarios. Disable it via --skip-init-data / SKIP_INIT_DATA=true and provide vetted scripts through INIT_DATA_PATH for production workloads.","title":"Security Note"},{"location":"v1/gateway/","text":"DocumentDB Gateway \u00b6 Overview \u00b6 The DocumentDB Gateway acts as a protocol translation layer between MongoDB clients and a PostgreSQL backend. It interprets MongoDB wire protocol, maps commands to PostgreSQL operations, and manages session handling, transactions, cursor-based paging, and TLS termination. \u00b6 MongoDB Request Translation \u00b6 The gateway converts MongoDB operations into PostgreSQL equivalents. Example: insertMany \u2192 PostgreSQL BATCH INSERT . Authentication & Session Management \u00b6 Supports SCRAM authentication. Authenticates against PostgreSQL credentials. Translates SCRAM flows to Postgres operations. Maintains sessions per user to enforce scoped permissions. User Management \u00b6 MongoDB commands like createUser , updateUser , dropUser are mapped to PostgreSQL. Roles supported: readAnyDatabase , readWriteAnyDatabase . PostgreSQL enforces access policies. Transactions \u00b6 Transactions tied to sessions via transaction_number . Managed through a TransactionStore : Tracks states: Started , Committed , Aborted . Prevents duplicates/conflicts. Uses PostgreSQL's BEGIN , COMMIT , ROLLBACK . Includes auto-cleanup for expired transactions. Paging & Cursors \u00b6 Mongo-style cursor paging \u2192 PostgreSQL LIMIT/OFFSET . Returns cursorId and first result batch. getMore fetches subsequent pages. CursorStore manages cursor lifecycle and cleanup. Pluggable Telemetry \u00b6 Supports custom telemetry backends via trait implementation. Logging, metrics, tracing supported. OpenTelemetry plugin support planned. Load Balancing & Failover (Planned) \u00b6 Planned read scaling via replica distribution. Writes routed to primary. Failover handling through: Primary detection Reconnect logic Transaction recovery via RecoveryToken Getting started with DocumentDB Gateway \u00b6 To get started with the DocumentDB Gateway, follow these steps: Build the Gateway : Build the DocumentDB Gateway using the provided Dockerfile. bash docker build . -f .github/containers/Build-Ubuntu/Dockerfile_gateway -t <image-tag> Run the Gateway : Run the DocumentDB Gateway in a Docker container. bash docker run -dt -p 10260:10260 -e USERNAME=<username> -e PASSWORD=<password> <image-tag> Connect to the Gateway : Use Mongosh to connect to the DocumentDB Gateway. bash mongosh localhost:10260 -u <username> -p <password> \\ --authenticationMechanism SCRAM-SHA-256 \\ --tls \\ --tlsAllowInvalidCertificates","title":"Gateway"},{"location":"v1/gateway/#documentdb-gateway","text":"","title":"DocumentDB Gateway"},{"location":"v1/gateway/#overview","text":"The DocumentDB Gateway acts as a protocol translation layer between MongoDB clients and a PostgreSQL backend. It interprets MongoDB wire protocol, maps commands to PostgreSQL operations, and manages session handling, transactions, cursor-based paging, and TLS termination.","title":"Overview"},{"location":"v1/gateway/#_1","text":"","title":""},{"location":"v1/gateway/#mongodb-request-translation","text":"The gateway converts MongoDB operations into PostgreSQL equivalents. Example: insertMany \u2192 PostgreSQL BATCH INSERT .","title":"MongoDB Request Translation"},{"location":"v1/gateway/#authentication-session-management","text":"Supports SCRAM authentication. Authenticates against PostgreSQL credentials. Translates SCRAM flows to Postgres operations. Maintains sessions per user to enforce scoped permissions.","title":"Authentication &amp; Session Management"},{"location":"v1/gateway/#user-management","text":"MongoDB commands like createUser , updateUser , dropUser are mapped to PostgreSQL. Roles supported: readAnyDatabase , readWriteAnyDatabase . PostgreSQL enforces access policies.","title":"User Management"},{"location":"v1/gateway/#transactions","text":"Transactions tied to sessions via transaction_number . Managed through a TransactionStore : Tracks states: Started , Committed , Aborted . Prevents duplicates/conflicts. Uses PostgreSQL's BEGIN , COMMIT , ROLLBACK . Includes auto-cleanup for expired transactions.","title":"Transactions"},{"location":"v1/gateway/#paging-cursors","text":"Mongo-style cursor paging \u2192 PostgreSQL LIMIT/OFFSET . Returns cursorId and first result batch. getMore fetches subsequent pages. CursorStore manages cursor lifecycle and cleanup.","title":"Paging &amp; Cursors"},{"location":"v1/gateway/#pluggable-telemetry","text":"Supports custom telemetry backends via trait implementation. Logging, metrics, tracing supported. OpenTelemetry plugin support planned.","title":"Pluggable Telemetry"},{"location":"v1/gateway/#load-balancing-failover-planned","text":"Planned read scaling via replica distribution. Writes routed to primary. Failover handling through: Primary detection Reconnect logic Transaction recovery via RecoveryToken","title":"Load Balancing &amp; Failover (Planned)"},{"location":"v1/gateway/#getting-started-with-documentdb-gateway","text":"To get started with the DocumentDB Gateway, follow these steps: Build the Gateway : Build the DocumentDB Gateway using the provided Dockerfile. bash docker build . -f .github/containers/Build-Ubuntu/Dockerfile_gateway -t <image-tag> Run the Gateway : Run the DocumentDB Gateway in a Docker container. bash docker run -dt -p 10260:10260 -e USERNAME=<username> -e PASSWORD=<password> <image-tag> Connect to the Gateway : Use Mongosh to connect to the DocumentDB Gateway. bash mongosh localhost:10260 -u <username> -p <password> \\ --authenticationMechanism SCRAM-SHA-256 \\ --tls \\ --tlsAllowInvalidCertificates","title":"Getting started with DocumentDB Gateway"},{"location":"v1/get-started/","text":"Get Started \u00b6 Pre-requisite \u00b6 Ensure Docker is installed on your system. Building DocumentDB with Docker \u00b6 Step 1: Clone the DocumentDB repo. git clone https://github.com/microsoft/documentdb.git Step 2: Create the docker image. Navigate to cloned repo. docker build . -f .devcontainer/Dockerfile -t documentdb Note: Validate using docker image ls Step 3: Run the Image as a container docker run -v $(pwd):/home/documentdb/code -it documentdb /bin/bash cd code (Aligns local location with docker image created, allows de-duplicating cloning repo again within image). Note: Validate container is running docker container ls Step 4: Build & Deploy the binaries make Note: Run in case of an unsuccessful build git config --global --add safe.directory /home/documentdb/code within image. sudo make install Note: To run backend postgresql tests after installing you can run make check . You are all set to work with DocumentDB. Using the Prebuilt Docker Image \u00b6 You can use a prebuilt docker image for DocumentDB instead of building it from source. Follow these steps: Pull the Prebuilt Image \u00b6 Pull the prebuilt image directly from the Microsoft Container Registry: docker pull mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG16-AMD64-0.103.0 Running the Prebuilt Image \u00b6 To run the prebuilt image, use one of the following commands: Run the container: docker run -dt mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG16-AMD64-0.103.0 If external access is required, run the container with parameter \"-e\": docker run -p 127.0.0.1:9712:9712 -dt mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG16-AMD64-0.103.0 -e This will start the container and map port 9712 from the container to the host. Connecting to the Server \u00b6 Internal Access \u00b6 Step 1: Run start_oss_server.sh to initialize the DocumentDB server and manage dependencies. ./scripts/start_oss_server.sh Or logging into the container if using prebuild image docker exec -it <container-id> bash Step 2: Connect to psql shell psql -p 9712 -d postgres External Access \u00b6 Connect to psql shell psql -h localhost --port 9712 -d postgres -U documentdb","title":"Get started"},{"location":"v1/get-started/#get-started","text":"","title":"Get Started"},{"location":"v1/get-started/#pre-requisite","text":"Ensure Docker is installed on your system.","title":"Pre-requisite"},{"location":"v1/get-started/#building-documentdb-with-docker","text":"Step 1: Clone the DocumentDB repo. git clone https://github.com/microsoft/documentdb.git Step 2: Create the docker image. Navigate to cloned repo. docker build . -f .devcontainer/Dockerfile -t documentdb Note: Validate using docker image ls Step 3: Run the Image as a container docker run -v $(pwd):/home/documentdb/code -it documentdb /bin/bash cd code (Aligns local location with docker image created, allows de-duplicating cloning repo again within image). Note: Validate container is running docker container ls Step 4: Build & Deploy the binaries make Note: Run in case of an unsuccessful build git config --global --add safe.directory /home/documentdb/code within image. sudo make install Note: To run backend postgresql tests after installing you can run make check . You are all set to work with DocumentDB.","title":"Building DocumentDB with Docker"},{"location":"v1/get-started/#using-the-prebuilt-docker-image","text":"You can use a prebuilt docker image for DocumentDB instead of building it from source. Follow these steps:","title":"Using the Prebuilt Docker Image"},{"location":"v1/get-started/#pull-the-prebuilt-image","text":"Pull the prebuilt image directly from the Microsoft Container Registry: docker pull mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG16-AMD64-0.103.0","title":"Pull the Prebuilt Image"},{"location":"v1/get-started/#running-the-prebuilt-image","text":"To run the prebuilt image, use one of the following commands: Run the container: docker run -dt mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG16-AMD64-0.103.0 If external access is required, run the container with parameter \"-e\": docker run -p 127.0.0.1:9712:9712 -dt mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG16-AMD64-0.103.0 -e This will start the container and map port 9712 from the container to the host.","title":"Running the Prebuilt Image"},{"location":"v1/get-started/#connecting-to-the-server","text":"","title":"Connecting to the Server"},{"location":"v1/get-started/#internal-access","text":"Step 1: Run start_oss_server.sh to initialize the DocumentDB server and manage dependencies. ./scripts/start_oss_server.sh Or logging into the container if using prebuild image docker exec -it <container-id> bash Step 2: Connect to psql shell psql -p 9712 -d postgres","title":"Internal Access"},{"location":"v1/get-started/#external-access","text":"Connect to psql shell psql -h localhost --port 9712 -d postgres -U documentdb","title":"External Access"},{"location":"v1/indexing/","text":"Indexing \u00b6 Create an Index \u00b6 DocumentDB uses the documentdb_api.create_indexes_background function, which allows background index creation without disrupting database operations. The SQL command demonstrates how to create a single field index on age on the patient collection of the documentdb . SELECT * FROM documentdb_api.create_indexes_background('documentdb', '{ \"createIndexes\": \"patient\", \"indexes\": [{ \"key\": {\"age\": 1},\"name\": \"idx_age\"}]}'); The SQL command demonstrates how to create a compound index on fields age and registration_year on the patient collection of the documentdb . SELECT * FROM documentdb_api.create_indexes_background('documentdb', '{ \"createIndexes\": \"patient\", \"indexes\": [{ \"key\": {\"registration_year\": 1, \"age\": 1},\"name\": \"idx_regyr_age\"}]}'); Drop an Index \u00b6 DocumentDB uses the documentdb_api.drop_indexes function, which allows you to remove an existing index from a collection. The SQL command demonstrates how to drop the index named id_ab_1 from the first_collection collection of the documentdb . CALL documentdb_api.drop_indexes('documentdb', '{\"dropIndexes\": \"patient\", \"index\":\"idx_age\"}');","title":"Indexing"},{"location":"v1/indexing/#indexing","text":"","title":"Indexing"},{"location":"v1/indexing/#create-an-index","text":"DocumentDB uses the documentdb_api.create_indexes_background function, which allows background index creation without disrupting database operations. The SQL command demonstrates how to create a single field index on age on the patient collection of the documentdb . SELECT * FROM documentdb_api.create_indexes_background('documentdb', '{ \"createIndexes\": \"patient\", \"indexes\": [{ \"key\": {\"age\": 1},\"name\": \"idx_age\"}]}'); The SQL command demonstrates how to create a compound index on fields age and registration_year on the patient collection of the documentdb . SELECT * FROM documentdb_api.create_indexes_background('documentdb', '{ \"createIndexes\": \"patient\", \"indexes\": [{ \"key\": {\"registration_year\": 1, \"age\": 1},\"name\": \"idx_regyr_age\"}]}');","title":"Create an Index"},{"location":"v1/indexing/#drop-an-index","text":"DocumentDB uses the documentdb_api.drop_indexes function, which allows you to remove an existing index from a collection. The SQL command demonstrates how to drop the index named id_ab_1 from the first_collection collection of the documentdb . CALL documentdb_api.drop_indexes('documentdb', '{\"dropIndexes\": \"patient\", \"index\":\"idx_age\"}');","title":"Drop an Index"},{"location":"v1/introduction/","text":"Introduction \u00b6 DocumentDB is the engine powering vCore-based Azure Cosmos DB for MongoDB. It offers a native implementation of document-oriented NoSQL database, enabling seamless CRUD operations on BSON data types within a PostgreSQL framework. Beyond basic operations, DocumentDB empowers you to execute complex workloads, including full-text searches, geospatial queries, and vector embeddings on your dataset, delivering robust functionality and flexibility for diverse data management needs. PostgreSQL is a powerful, open source object-relational database system that uses and extends the SQL language combined with many features that safely store and scale the most complicated data workloads. Components \u00b6 The project comprises of two primary components, which work together to support document operations. pg_documentdb_core : PostgreSQL extension introducing BSON datatype support and operations for native Postgres. pg_documentdb : The public API surface for DocumentDB providing CRUD functionality on documents in the store.","title":"Introduction"},{"location":"v1/introduction/#introduction","text":"DocumentDB is the engine powering vCore-based Azure Cosmos DB for MongoDB. It offers a native implementation of document-oriented NoSQL database, enabling seamless CRUD operations on BSON data types within a PostgreSQL framework. Beyond basic operations, DocumentDB empowers you to execute complex workloads, including full-text searches, geospatial queries, and vector embeddings on your dataset, delivering robust functionality and flexibility for diverse data management needs. PostgreSQL is a powerful, open source object-relational database system that uses and extends the SQL language combined with many features that safely store and scale the most complicated data workloads.","title":"Introduction"},{"location":"v1/introduction/#components","text":"The project comprises of two primary components, which work together to support document operations. pg_documentdb_core : PostgreSQL extension introducing BSON datatype support and operations for native Postgres. pg_documentdb : The public API surface for DocumentDB providing CRUD functionality on documents in the store.","title":"Components"},{"location":"v1/joins/","text":"Join data from multiple collections \u00b6 Let's create an additional collection named appointment to demonstrate how a join operation can be performed. select documentdb_api.insert_one('documentdb','appointment', '{\"appointment_id\": \"A001\", \"patient_id\": \"P001\", \"doctor_name\": \"Dr. Milind\", \"appointment_date\": \"2023-01-20\", \"reason\": \"Routine checkup\" }'); select documentdb_api.insert_one('documentdb','appointment', '{\"appointment_id\": \"A002\", \"patient_id\": \"P001\", \"doctor_name\": \"Dr. Moore\", \"appointment_date\": \"2023-02-10\", \"reason\": \"Follow-up\"}'); select documentdb_api.insert_one('documentdb','appointment', '{\"appointment_id\": \"A004\", \"patient_id\": \"P003\", \"doctor_name\": \"Dr. Smith\", \"appointment_date\": \"2024-03-12\", \"reason\": \"Allergy consultation\"}'); select documentdb_api.insert_one('documentdb','appointment', '{\"appointment_id\": \"A005\", \"patient_id\": \"P004\", \"doctor_name\": \"Dr. Moore\", \"appointment_date\": \"2024-04-15\", \"reason\": \"Migraine treatment\"}'); select documentdb_api.insert_one('documentdb','appointment', '{\"appointment_id\": \"A007\",\"patient_id\": \"P001\", \"doctor_name\": \"Dr. Milind\", \"appointment_date\": \"2024-06-05\", \"reason\": \"Blood test\"}'); select documentdb_api.insert_one('documentdb','appointment', '{ \"appointment_id\": \"A009\", \"patient_id\": \"P003\", \"doctor_name\": \"Dr. Smith\",\"appointment_date\": \"2025-01-20\", \"reason\": \"Follow-up visit\"}'); The example presents each patient along with the doctors visited. SELECT cursorpage FROM documentdb_api.aggregate_cursor_first_page('documentdb', '{ \"aggregate\": \"patient\", \"pipeline\": [ { \"$lookup\": { \"from\": \"appointment\",\"localField\": \"patient_id\", \"foreignField\": \"patient_id\", \"as\": \"appointment\" } },{\"$unwind\":\"$appointment\"},{\"$project\":{\"_id\":0,\"name\":1,\"appointment.doctor_name\":1,\"appointment.appointment_date\":1}} ], \"cursor\": { \"batchSize\": 3 } }');","title":"Joins"},{"location":"v1/joins/#join-data-from-multiple-collections","text":"Let's create an additional collection named appointment to demonstrate how a join operation can be performed. select documentdb_api.insert_one('documentdb','appointment', '{\"appointment_id\": \"A001\", \"patient_id\": \"P001\", \"doctor_name\": \"Dr. Milind\", \"appointment_date\": \"2023-01-20\", \"reason\": \"Routine checkup\" }'); select documentdb_api.insert_one('documentdb','appointment', '{\"appointment_id\": \"A002\", \"patient_id\": \"P001\", \"doctor_name\": \"Dr. Moore\", \"appointment_date\": \"2023-02-10\", \"reason\": \"Follow-up\"}'); select documentdb_api.insert_one('documentdb','appointment', '{\"appointment_id\": \"A004\", \"patient_id\": \"P003\", \"doctor_name\": \"Dr. Smith\", \"appointment_date\": \"2024-03-12\", \"reason\": \"Allergy consultation\"}'); select documentdb_api.insert_one('documentdb','appointment', '{\"appointment_id\": \"A005\", \"patient_id\": \"P004\", \"doctor_name\": \"Dr. Moore\", \"appointment_date\": \"2024-04-15\", \"reason\": \"Migraine treatment\"}'); select documentdb_api.insert_one('documentdb','appointment', '{\"appointment_id\": \"A007\",\"patient_id\": \"P001\", \"doctor_name\": \"Dr. Milind\", \"appointment_date\": \"2024-06-05\", \"reason\": \"Blood test\"}'); select documentdb_api.insert_one('documentdb','appointment', '{ \"appointment_id\": \"A009\", \"patient_id\": \"P003\", \"doctor_name\": \"Dr. Smith\",\"appointment_date\": \"2025-01-20\", \"reason\": \"Follow-up visit\"}'); The example presents each patient along with the doctors visited. SELECT cursorpage FROM documentdb_api.aggregate_cursor_first_page('documentdb', '{ \"aggregate\": \"patient\", \"pipeline\": [ { \"$lookup\": { \"from\": \"appointment\",\"localField\": \"patient_id\", \"foreignField\": \"patient_id\", \"as\": \"appointment\" } },{\"$unwind\":\"$appointment\"},{\"$project\":{\"_id\":0,\"name\":1,\"appointment.doctor_name\":1,\"appointment.appointment_date\":1}} ], \"cursor\": { \"batchSize\": 3 } }');","title":"Join data from multiple collections"},{"location":"v1/packaging/","text":"To Build Your Own Debian Packages With Docker \u00b6 Run ./packaging/build_packages.sh -h and follow the instructions. E.g. to build for Debian 12 and PostgreSQL 16, run: ./packaging/build_packages.sh --os deb12 --pg 16 Packages can be found at the packages directory by default, but it can be configured with the --output-dir option. Note: The packages do not include pg_documentdb_distributed in the internal directory.","title":"To Build Your Own Debian Packages With Docker"},{"location":"v1/packaging/#to-build-your-own-debian-packages-with-docker","text":"Run ./packaging/build_packages.sh -h and follow the instructions. E.g. to build for Debian 12 and PostgreSQL 16, run: ./packaging/build_packages.sh --os deb12 --pg 16 Packages can be found at the packages directory by default, but it can be configured with the --output-dir option. Note: The packages do not include pg_documentdb_distributed in the internal directory.","title":"To Build Your Own Debian Packages With Docker"},{"location":"v1/prebuild/","text":"To Build Ubuntu prebuild image \u00b6 E.g. to build for Ubuntu 22.04, PostgreSQL 16, amd64 and documentdb_0.103.0, run: docker build -t <image-tag> -f .github/containers/Build-Ubuntu/Dockerfile_prebuild \\ --platform=linux/amd64 --build-arg BASE_IMAGE=ubuntu:22.04 --build-arg POSTGRES_VERSION=16 \\ --build-arg DEB_PACKAGE_REL_PATH=packaging/packages/ubuntu22.04-postgresql-16-documentdb_0.103.0_amd64.deb . To use the image \u00b6 Step 1: Running the container in detached mode docker run -dt <image-tag> docker exec -it <container-id> bash Step 2: Connect to psql shell psql -p 9712 -d postgres Prebuild Image List \u00b6 Check the prebuild image list for the latest prebuild images.","title":"Prebuild Images"},{"location":"v1/prebuild/#to-build-ubuntu-prebuild-image","text":"E.g. to build for Ubuntu 22.04, PostgreSQL 16, amd64 and documentdb_0.103.0, run: docker build -t <image-tag> -f .github/containers/Build-Ubuntu/Dockerfile_prebuild \\ --platform=linux/amd64 --build-arg BASE_IMAGE=ubuntu:22.04 --build-arg POSTGRES_VERSION=16 \\ --build-arg DEB_PACKAGE_REL_PATH=packaging/packages/ubuntu22.04-postgresql-16-documentdb_0.103.0_amd64.deb .","title":"To Build Ubuntu prebuild image"},{"location":"v1/prebuild/#to-use-the-image","text":"Step 1: Running the container in detached mode docker run -dt <image-tag> docker exec -it <container-id> bash Step 2: Connect to psql shell psql -p 9712 -d postgres","title":"To use the image"},{"location":"v1/prebuild/#prebuild-image-list","text":"Check the prebuild image list for the latest prebuild images.","title":"Prebuild Image List"},{"location":"v1/prebuild_image_list/","text":"Documentdb Prebuild Docker Images List \u00b6 v0.103.0 \u00b6 Ubuntu 22.04 \u00b6 Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG17-AMD64-0.103.0 OS: Ubuntu 22.04 Database: PostgreSQL 17 Architecture: AMD64 Version: 0.103.0 Digest: sha256:5c7765af1ac51ff894e2795d5ee8c6bcca7ea90159d38c40b1c164feef18037d Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG17-ARM64-0.103.0 OS: Ubuntu 22.04 Database: PostgreSQL 17 Architecture: ARM64 Version: 0.103.0 Digest: sha256:98d8abfb65f8dbb23dcd87d819496af0c9955c0234ff542ff18c16a294d6478f Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG16-AMD64-0.103.0 OS: Ubuntu 22.04 Database: PostgreSQL 16 Architecture: AMD64 Version: 0.103.0 Digest: sha256:e0f2b7c9115bec5692679fe3afe2eaf1dc268db14282585cc7bae047cd50325c Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG16-ARM64-0.103.0 OS: Ubuntu 22.04 Database: PostgreSQL 16 Architecture: ARM64 Version: 0.103.0 Digest: sha256:62e2b4c2f39de9e81c432a889d4268cfc1c335cbe4878517ee0760ea33739477 Ubuntu 24.04 \u00b6 Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:24.04-PG17-AMD64-0.103.0 OS: Ubuntu 24.04 Database: PostgreSQL 17 Architecture: AMD64 Version: 0.103.0 Digest: sha256:a6f72e31c9d9b39a7ac201ac41f6d77b439e048d892f6edddcb4b06774cc6292 Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:24.04-PG17-ARM64-0.103.0 OS: Ubuntu 24.04 Database: PostgreSQL 17 Architecture: ARM64 Version: 0.103.0 Digest: sha256:621eb5f5ea380d152a254a2f2d35e169c3ae217cb940f6090fbb07040dcd2c67 Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:24.04-PG16-AMD64-0.103.0 OS: Ubuntu 24.04 Database: PostgreSQL 16 Architecture: AMD64 Version: 0.103.0 Digest: sha256:dc4f0155e545ae14bcf65d31d4b9d21c8fdfee42d467f3419106ced8e141a6bd Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:24.04-PG16-ARM64-0.103.0 OS: Ubuntu 24.04 Database: PostgreSQL 16 Architecture: ARM64 Version: 0.103.0 Digest: sha256:162df47ba5e8b10f88d7bd0e2e7c5775e764774928920ea532c372c5ee360b24 Notes \u00b6 Ensure each image meets your environment requirements and compatibility needs. Refer to the official documentation for setup instructions and best practices.","title":"Documentdb Prebuild Docker Images List"},{"location":"v1/prebuild_image_list/#documentdb-prebuild-docker-images-list","text":"","title":"Documentdb Prebuild Docker Images List"},{"location":"v1/prebuild_image_list/#v01030","text":"","title":"v0.103.0"},{"location":"v1/prebuild_image_list/#ubuntu-2204","text":"Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG17-AMD64-0.103.0 OS: Ubuntu 22.04 Database: PostgreSQL 17 Architecture: AMD64 Version: 0.103.0 Digest: sha256:5c7765af1ac51ff894e2795d5ee8c6bcca7ea90159d38c40b1c164feef18037d Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG17-ARM64-0.103.0 OS: Ubuntu 22.04 Database: PostgreSQL 17 Architecture: ARM64 Version: 0.103.0 Digest: sha256:98d8abfb65f8dbb23dcd87d819496af0c9955c0234ff542ff18c16a294d6478f Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG16-AMD64-0.103.0 OS: Ubuntu 22.04 Database: PostgreSQL 16 Architecture: AMD64 Version: 0.103.0 Digest: sha256:e0f2b7c9115bec5692679fe3afe2eaf1dc268db14282585cc7bae047cd50325c Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:22.04-PG16-ARM64-0.103.0 OS: Ubuntu 22.04 Database: PostgreSQL 16 Architecture: ARM64 Version: 0.103.0 Digest: sha256:62e2b4c2f39de9e81c432a889d4268cfc1c335cbe4878517ee0760ea33739477","title":"Ubuntu 22.04"},{"location":"v1/prebuild_image_list/#ubuntu-2404","text":"Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:24.04-PG17-AMD64-0.103.0 OS: Ubuntu 24.04 Database: PostgreSQL 17 Architecture: AMD64 Version: 0.103.0 Digest: sha256:a6f72e31c9d9b39a7ac201ac41f6d77b439e048d892f6edddcb4b06774cc6292 Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:24.04-PG17-ARM64-0.103.0 OS: Ubuntu 24.04 Database: PostgreSQL 17 Architecture: ARM64 Version: 0.103.0 Digest: sha256:621eb5f5ea380d152a254a2f2d35e169c3ae217cb940f6090fbb07040dcd2c67 Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:24.04-PG16-AMD64-0.103.0 OS: Ubuntu 24.04 Database: PostgreSQL 16 Architecture: AMD64 Version: 0.103.0 Digest: sha256:dc4f0155e545ae14bcf65d31d4b9d21c8fdfee42d467f3419106ced8e141a6bd Image Name: mcr.microsoft.com/cosmosdb/ubuntu/documentdb-oss:24.04-PG16-ARM64-0.103.0 OS: Ubuntu 24.04 Database: PostgreSQL 16 Architecture: ARM64 Version: 0.103.0 Digest: sha256:162df47ba5e8b10f88d7bd0e2e7c5775e764774928920ea532c372c5ee360b24","title":"Ubuntu 24.04"},{"location":"v1/prebuild_image_list/#notes","text":"Ensure each image meets your environment requirements and compatibility needs. Refer to the official documentation for setup instructions and best practices.","title":"Notes"},{"location":"v1/usage/","text":"Usage \u00b6 Once you have your DocumentDB set up running, you can start with creating collections, indexes and perform queries on them. Create a collection \u00b6 DocumentDB provides documentdb_api.create_collection function to create a new collection within a specified database, enabling you to manage and organize your BSON documents effectively. SELECT documentdb_api.create_collection('documentdb','patient'); Perform CRUD operations \u00b6 Insert documents \u00b6 The documentdb_api.insert_one command is used to add a single document into a collection. select documentdb_api.insert_one('documentdb','patient', '{ \"patient_id\": \"P001\", \"name\": \"Alice Smith\", \"age\": 30, \"phone_number\": \"555-0123\", \"registration_year\": \"2023\",\"conditions\": [\"Diabetes\", \"Hypertension\"]}'); select documentdb_api.insert_one('documentdb','patient', '{ \"patient_id\": \"P002\", \"name\": \"Bob Johnson\", \"age\": 45, \"phone_number\": \"555-0456\", \"registration_year\": \"2023\", \"conditions\": [\"Asthma\"]}'); select documentdb_api.insert_one('documentdb','patient', '{ \"patient_id\": \"P003\", \"name\": \"Charlie Brown\", \"age\": 29, \"phone_number\": \"555-0789\", \"registration_year\": \"2024\", \"conditions\": [\"Allergy\", \"Anemia\"]}'); select documentdb_api.insert_one('documentdb','patient', '{ \"patient_id\": \"P004\", \"name\": \"Diana Prince\", \"age\": 40, \"phone_number\": \"555-0987\", \"registration_year\": \"2024\", \"conditions\": [\"Migraine\"]}'); select documentdb_api.insert_one('documentdb','patient', '{ \"patient_id\": \"P005\", \"name\": \"Edward Norton\", \"age\": 55, \"phone_number\": \"555-1111\", \"registration_year\": \"2025\", \"conditions\": [\"Hypertension\", \"Heart Disease\"]}'); Read document from a collection \u00b6 The documentdb_api.collection function is used for retrieving the documents in a collection. SELECT document FROM documentdb_api.collection('documentdb','patient'); Alternatively, we can apply filter to our queries. SET search_path TO documentdb_api, documentdb_core; SET documentdb_core.bsonUseEJson TO true; SELECT cursorPage FROM documentdb_api.find_cursor_first_page('documentdb', '{ \"find\" : \"patient\", \"filter\" : {\"patient_id\":\"P005\"}}'); We can perform range queries as well. SELECT cursorPage FROM documentdb_api.find_cursor_first_page('documentdb', '{ \"find\" : \"patient\", \"filter\" : { \"$and\": [{ \"age\": { \"$gte\": 10 } },{ \"age\": { \"$lte\": 35 } }] }}'); Update document in a collection \u00b6 DocumentDB uses the documentdb_api.update function to modify existing documents within a collection. The SQL command updates the age for patient P004 . select documentdb_api.update('documentdb', '{\"update\":\"patient\", \"updates\":[{\"q\":{\"patient_id\":\"P004\"},\"u\":{\"$set\":{\"age\":14}}}]}'); Similarly, we can update multiple documents using multi property. SELECT documentdb_api.update('documentdb', '{\"update\":\"patient\", \"updates\":[{\"q\":{},\"u\":{\"$set\":{\"age\":24}},\"multi\":true}]}'); Delete document from the collection \u00b6 DocumentDB uses the documentdb_api.delete function for precise document removal based on specified criteria. The SQL command deletes the document for patient P002 . SELECT documentdb_api.delete('documentdb', '{\"delete\": \"patient\", \"deletes\": [{\"q\": {\"patient_id\": \"P002\"}, \"limit\": 1}]}');","title":"Usage"},{"location":"v1/usage/#usage","text":"Once you have your DocumentDB set up running, you can start with creating collections, indexes and perform queries on them.","title":"Usage"},{"location":"v1/usage/#create-a-collection","text":"DocumentDB provides documentdb_api.create_collection function to create a new collection within a specified database, enabling you to manage and organize your BSON documents effectively. SELECT documentdb_api.create_collection('documentdb','patient');","title":"Create a collection"},{"location":"v1/usage/#perform-crud-operations","text":"","title":"Perform CRUD operations"},{"location":"v1/usage/#insert-documents","text":"The documentdb_api.insert_one command is used to add a single document into a collection. select documentdb_api.insert_one('documentdb','patient', '{ \"patient_id\": \"P001\", \"name\": \"Alice Smith\", \"age\": 30, \"phone_number\": \"555-0123\", \"registration_year\": \"2023\",\"conditions\": [\"Diabetes\", \"Hypertension\"]}'); select documentdb_api.insert_one('documentdb','patient', '{ \"patient_id\": \"P002\", \"name\": \"Bob Johnson\", \"age\": 45, \"phone_number\": \"555-0456\", \"registration_year\": \"2023\", \"conditions\": [\"Asthma\"]}'); select documentdb_api.insert_one('documentdb','patient', '{ \"patient_id\": \"P003\", \"name\": \"Charlie Brown\", \"age\": 29, \"phone_number\": \"555-0789\", \"registration_year\": \"2024\", \"conditions\": [\"Allergy\", \"Anemia\"]}'); select documentdb_api.insert_one('documentdb','patient', '{ \"patient_id\": \"P004\", \"name\": \"Diana Prince\", \"age\": 40, \"phone_number\": \"555-0987\", \"registration_year\": \"2024\", \"conditions\": [\"Migraine\"]}'); select documentdb_api.insert_one('documentdb','patient', '{ \"patient_id\": \"P005\", \"name\": \"Edward Norton\", \"age\": 55, \"phone_number\": \"555-1111\", \"registration_year\": \"2025\", \"conditions\": [\"Hypertension\", \"Heart Disease\"]}');","title":"Insert documents"},{"location":"v1/usage/#read-document-from-a-collection","text":"The documentdb_api.collection function is used for retrieving the documents in a collection. SELECT document FROM documentdb_api.collection('documentdb','patient'); Alternatively, we can apply filter to our queries. SET search_path TO documentdb_api, documentdb_core; SET documentdb_core.bsonUseEJson TO true; SELECT cursorPage FROM documentdb_api.find_cursor_first_page('documentdb', '{ \"find\" : \"patient\", \"filter\" : {\"patient_id\":\"P005\"}}'); We can perform range queries as well. SELECT cursorPage FROM documentdb_api.find_cursor_first_page('documentdb', '{ \"find\" : \"patient\", \"filter\" : { \"$and\": [{ \"age\": { \"$gte\": 10 } },{ \"age\": { \"$lte\": 35 } }] }}');","title":"Read document from a collection"},{"location":"v1/usage/#update-document-in-a-collection","text":"DocumentDB uses the documentdb_api.update function to modify existing documents within a collection. The SQL command updates the age for patient P004 . select documentdb_api.update('documentdb', '{\"update\":\"patient\", \"updates\":[{\"q\":{\"patient_id\":\"P004\"},\"u\":{\"$set\":{\"age\":14}}}]}'); Similarly, we can update multiple documents using multi property. SELECT documentdb_api.update('documentdb', '{\"update\":\"patient\", \"updates\":[{\"q\":{},\"u\":{\"$set\":{\"age\":24}},\"multi\":true}]}');","title":"Update document in a collection"},{"location":"v1/usage/#delete-document-from-the-collection","text":"DocumentDB uses the documentdb_api.delete function for precise document removal based on specified criteria. The SQL command deletes the document for patient P002 . SELECT documentdb_api.delete('documentdb', '{\"delete\": \"patient\", \"deletes\": [{\"q\": {\"patient_id\": \"P002\"}, \"limit\": 1}]}');","title":"Delete document from the collection"},{"location":"v1/why-documentdb/","text":"Why DocumentDB ? \u00b6 At DocumentDB, we believe in the power of open-source to drive innovation and collaboration. Our commitment to being a fully open-source document database means that we are dedicated to transparency, community involvement, and continuous improvement. We are open-sourced under the most permissive MIT license, where developers and organizations alike have no restrictions incorporating the project into new and existing solutions of their own. DocumentDB introduces the BSON data type and provides APIs for seamless operation within native PostgreSQL, enhancing efficiency and aligning with operational advantages. DocumentDB also provides a powerful on-premise solution, allowing organizations to maintain full control over their data and infrastructure. This flexibility ensures that you can deploy it in your own environment, meeting your specific security, compliance, and performance requirements. With DocumentDB, you get the best of both worlds: the innovation of open-source and the control of on-premise deployment. Based on Postgres \u00b6 DocumentDB is built on top of PostgreSQL, one of the most advanced and reliable open-source relational database systems available. We chose PostgreSQL as our base layer for several reasons: Proven Stability and Performance : PostgreSQL has a long history of stability and performance, making it a trusted choice for mission-critical applications. Extensibility : Their extensible architecture allows us to integrate a DocumentDB API on BSON data type seamlessly, providing the flexibility to handle both relational and document data. Active Community : PostgreSQL has a vibrant and active community that continuously contributes to its development, ensuring that it remains at the forefront of database technology. Advanced Features : PostgreSQL offers a rich set of features, including advanced indexing, full-text search, and powerful querying capabilities, which enhance the functionality of DocumentDB. Compliance and Security : PostgreSQL's robust security features and compliance with various standards make it an ideal choice for organizations with stringent security and regulatory requirements. By building on PostgreSQL, DocumentDB leverages these strengths to provide a powerful, flexible, and reliable document database that meets the need of modern applications. DocumentDB will continue to benefit from the advancements brought into the PostgreSQL ecosystem.","title":"Why documentdb"},{"location":"v1/why-documentdb/#why-documentdb","text":"At DocumentDB, we believe in the power of open-source to drive innovation and collaboration. Our commitment to being a fully open-source document database means that we are dedicated to transparency, community involvement, and continuous improvement. We are open-sourced under the most permissive MIT license, where developers and organizations alike have no restrictions incorporating the project into new and existing solutions of their own. DocumentDB introduces the BSON data type and provides APIs for seamless operation within native PostgreSQL, enhancing efficiency and aligning with operational advantages. DocumentDB also provides a powerful on-premise solution, allowing organizations to maintain full control over their data and infrastructure. This flexibility ensures that you can deploy it in your own environment, meeting your specific security, compliance, and performance requirements. With DocumentDB, you get the best of both worlds: the innovation of open-source and the control of on-premise deployment.","title":"Why DocumentDB ?"},{"location":"v1/why-documentdb/#based-on-postgres","text":"DocumentDB is built on top of PostgreSQL, one of the most advanced and reliable open-source relational database systems available. We chose PostgreSQL as our base layer for several reasons: Proven Stability and Performance : PostgreSQL has a long history of stability and performance, making it a trusted choice for mission-critical applications. Extensibility : Their extensible architecture allows us to integrate a DocumentDB API on BSON data type seamlessly, providing the flexibility to handle both relational and document data. Active Community : PostgreSQL has a vibrant and active community that continuously contributes to its development, ensuring that it remains at the forefront of database technology. Advanced Features : PostgreSQL offers a rich set of features, including advanced indexing, full-text search, and powerful querying capabilities, which enhance the functionality of DocumentDB. Compliance and Security : PostgreSQL's robust security features and compliance with various standards make it an ideal choice for organizations with stringent security and regulatory requirements. By building on PostgreSQL, DocumentDB leverages these strengths to provide a powerful, flexible, and reliable document database that meets the need of modern applications. DocumentDB will continue to benefit from the advancements brought into the PostgreSQL ecosystem.","title":"Based on Postgres"}]}