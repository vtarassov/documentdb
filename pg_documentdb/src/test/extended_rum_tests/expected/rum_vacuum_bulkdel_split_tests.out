SET search_path TO documentdb_api_catalog, documentdb_core, public;
SET documentdb.next_collection_id TO 800;
SET documentdb.next_collection_index_id TO 800;
set documentdb_rum.prune_rum_empty_pages to on;
set documentdb_rum.enable_new_bulk_delete to on;
set documentdb_rum.enable_new_bulk_delete_inline_data_pages to on;
set documentdb_rum.vacuum_cleanup_entries to on;
SELECT documentdb_api.drop_collection('pvacuum_split_db', 'pbulkdel');
 drop_collection 
-----------------
 f
(1 row)

SELECT documentdb_api.create_collection('pvacuum_split_db', 'pbulkdel');
NOTICE:  creating collection
 create_collection 
-------------------
 t
(1 row)

SELECT collection_id AS vacuum_col FROM documentdb_api_catalog.collections WHERE database_name = 'pvacuum_split_db' AND collection_name = 'pbulkdel' \gset
-- disable autovacuum to have predicatability
SELECT FORMAT('ALTER TABLE documentdb_data.documents_%s set (autovacuum_enabled = off)', :vacuum_col) \gexec
ALTER TABLE documentdb_data.documents_801 set (autovacuum_enabled = off)
-- insert 500 rows (generates many entry pages)
SELECT COUNT(documentdb_api.insert_one('pvacuum_split_db', 'pbulkdel',  FORMAT('{ "_id": %s, "a": %s }', i, i)::bson)) FROM generate_series(1, 500) AS i;
 count 
-------
   500
(1 row)

SELECT documentdb_api_internal.create_indexes_non_concurrently(
    'pvacuum_split_db',
    '{ "createIndexes": "pbulkdel", "indexes": [ { "key": { "a": 1 }, "name": "a_1", "enableCompositeTerm": true } ] }', TRUE);
                                                                                                   create_indexes_non_concurrently                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 { "raw" : { "defaultShard" : { "numIndexesBefore" : { "$numberInt" : "1" }, "numIndexesAfter" : { "$numberInt" : "2" }, "createdCollectionAutomatically" : false, "ok" : { "$numberInt" : "1" } } }, "ok" : { "$numberInt" : "1" } }
(1 row)

SELECT index_id AS vacuum_index_id FROM documentdb_api_catalog.collection_indexes WHERE collection_id = :vacuum_col AND index_id != :vacuum_col \gset
-- print stats per page
SELECT documentdb_api_internal.documentdb_rum_get_meta_page_info(public.get_raw_page('documentdb_data.documents_rum_index_802', 0));
                             documentdb_rum_get_meta_page_info                              
--------------------------------------------------------------------------------------------
 {"entries": 500, "dataPages": 0, "entryPages": 4, "totalPages": 5, "pendingHeapTuples": 0}
(1 row)

-- insert many tuples at the end (this splits it to the higher pages)
SELECT COUNT(documentdb_api.insert_one('pvacuum_split_db', 'pbulkdel',  FORMAT('{ "_id": %s, "a": %s }', i, i)::bson)) FROM generate_series(501, 2500) AS i;
 count 
-------
  2000
(1 row)

SELECT COUNT(documentdb_api.insert_one('pvacuum_split_db', 'pbulkdel',  FORMAT('{ "_id": %s, "a": %s }', i, i)::bson)) FROM generate_series(2501, 5000) AS i;
 count 
-------
  2500
(1 row)

-- vacuum the collection
SELECT FORMAT('VACUUM (FREEZE ON, INDEX_CLEANUP ON, DISABLE_PAGE_SKIPPING ON) documentdb_data.documents_%s;', :vacuum_col) \gexec
VACUUM (FREEZE ON, INDEX_CLEANUP ON, DISABLE_PAGE_SKIPPING ON) documentdb_data.documents_801;
-- print stats per page
SELECT documentdb_api_internal.documentdb_rum_get_meta_page_info(public.get_raw_page('documentdb_data.documents_rum_index_802', 0));
                               documentdb_rum_get_meta_page_info                               
-----------------------------------------------------------------------------------------------
 {"entries": 5000, "dataPages": 0, "entryPages": 35, "totalPages": 36, "pendingHeapTuples": 0}
(1 row)

-- now delete the earlier rows in the tree (occupying the lower pages)
SELECT documentdb_api.delete('pvacuum_split_db', '{ "delete": "pbulkdel", "deletes": [ { "q": { "_id": { "$lte": 3000 } }, "limit": 0 } ]}');
                                          delete                                           
-------------------------------------------------------------------------------------------
 ("{ ""n"" : { ""$numberInt"" : ""3000"" }, ""ok"" : { ""$numberDouble"" : ""1.0"" } }",t)
(1 row)

-- vacuum the collection (twice to ensure we have void pages): but make sure to skip the visibility check (to ensure we get void pages)
set documentdb_rum.skip_global_visibility_check_on_prune to on;
set client_min_messages to LOG;
SELECT FORMAT('VACUUM (FREEZE ON, INDEX_CLEANUP ON, DISABLE_PAGE_SKIPPING ON) documentdb_data.documents_%s;', :vacuum_col) \gexec
VACUUM (FREEZE ON, INDEX_CLEANUP ON, DISABLE_PAGE_SKIPPING ON) documentdb_data.documents_801;
LOG:  Vacuum[index=19205,vacuumCleanup=0] emptyEntryPages=20, emptyEntries=3000, emptyPostingTrees=0, prunedEntries=2980, prunedPages=19,prunedPostingTrees=0, postingPagesDeleted=0, emptyPostingPages=0, numBacktracks=0, isNewBulkDelete=1, numEntryPages=35, numDataPages=0, numVoidPages=0
LOG:  Vacuum[index=19205,vacuumCleanup=1] emptyEntryPages=0, emptyEntries=0, emptyPostingTrees=0, prunedEntries=0, prunedPages=0,prunedPostingTrees=0, postingPagesDeleted=0, emptyPostingPages=0, numBacktracks=0, isNewBulkDelete=1, numEntryPages=16, numDataPages=0, numVoidPages=19
reset client_min_messages;
-- print stats per page: Note that the min/max dead pages that are void are less than 36.
SELECT documentdb_api_internal.documentdb_rum_get_meta_page_info(public.get_raw_page('documentdb_data.documents_rum_index_802', 0));
                               documentdb_rum_get_meta_page_info                               
-----------------------------------------------------------------------------------------------
 {"entries": 2001, "dataPages": 0, "entryPages": 16, "totalPages": 36, "pendingHeapTuples": 0}
(1 row)

SELECT MIN(i), MAX(i), COUNT(*) FROM (SELECT i, documentdb_api_internal.documentdb_rum_page_get_stats(public.get_raw_page('documentdb_data.documents_rum_index_802', i)) entry FROM generate_series(1, 35) i) AS q1
    WHERE entry->>'flagsStr' LIKE '%HALFDEAD%' OR entry->>'flagsStr' LIKE '%DELETED%';
 min | max | count 
-----+-----+-------
   2 |  21 |    19
(1 row)

-- now that there's void pages, insert many docs to induce page splits (and that should reuse earlier pages).
-- do this wiht a fixed cycleId (that we can later reuse for vacuum)
set documentdb_rum.vacuum_cycle_id_override to 917;
SELECT COUNT(documentdb_api.insert_one('pvacuum_split_db', 'pbulkdel',  FORMAT('{ "_id": %s.5, "a": %s.5 }', i, i)::bson)) FROM generate_series(3001, 5000) AS i;
 count 
-------
  2000
(1 row)

SELECT COUNT(documentdb_api.insert_one('pvacuum_split_db', 'pbulkdel',  FORMAT('{ "_id": %s.6, "a": %s.6 }', i, i)::bson)) FROM generate_series(3001, 5000) AS i;
 count 
-------
  2000
(1 row)

SELECT COUNT(documentdb_api.insert_one('pvacuum_split_db', 'pbulkdel',  FORMAT('{ "_id": %s.3, "a": %s.3 }', i, i)::bson)) FROM generate_series(3001, 5000) AS i;
 count 
-------
  2000
(1 row)

-- should have no deleted/dead pages (all reused)
SELECT MIN(i), MAX(i), COUNT(*) FROM (SELECT i, documentdb_api_internal.documentdb_rum_page_get_stats(public.get_raw_page('documentdb_data.documents_rum_index_802', i)) entry FROM generate_series(1, 56) i) AS q1
    WHERE entry->>'flagsStr' LIKE '%HALFDEAD%' OR entry->>'flagsStr' LIKE '%DELETED%';
 min | max | count 
-----+-----+-------
     |     |     0
(1 row)

-- at least some pages should have a right link less than the current page
SELECT COUNT(*) FROM (SELECT i, documentdb_api_internal.documentdb_rum_page_get_stats(public.get_raw_page('documentdb_data.documents_rum_index_802', i)) entry FROM generate_series(1, 56) i) AS q1
    WHERE (entry->>'rightLink')::int4 < i;
 count 
-------
    21
(1 row)

-- the new pages should have the appropriate vacuum cycleId
SELECT COUNT(*), MIN((entry->>'cycleId')::int4), MAX((entry->>'cycleId')::int4) FROM (SELECT i, documentdb_api_internal.documentdb_rum_page_get_stats(public.get_raw_page('documentdb_data.documents_rum_index_802', i)) entry FROM generate_series(1, 56) i) AS q1
    WHERE (entry->>'cycleId')::int4 > 0;
 count | min | max 
-------+-----+-----
    54 | 917 | 917
(1 row)

-- delete everything
SELECT documentdb_api.delete('pvacuum_split_db', '{ "delete": "pbulkdel", "deletes": [ { "q": { }, "limit": 0 } ]}');
                                          delete                                           
-------------------------------------------------------------------------------------------
 ("{ ""n"" : { ""$numberInt"" : ""8000"" }, ""ok"" : { ""$numberDouble"" : ""1.0"" } }",t)
(1 row)

-- run a vacuum in the mode that only works on backtrack mode.
set documentdb_rum.default_traverse_rum_page_only_on_backtrack to on;
set client_min_messages to LOG;
SELECT FORMAT('VACUUM (FREEZE ON, INDEX_CLEANUP ON, DISABLE_PAGE_SKIPPING ON) documentdb_data.documents_%s;', :vacuum_col) \gexec
VACUUM (FREEZE ON, INDEX_CLEANUP ON, DISABLE_PAGE_SKIPPING ON) documentdb_data.documents_801;
LOG:  Vacuum[index=19205,vacuumCleanup=0] emptyEntryPages=55, emptyEntries=8001, emptyPostingTrees=0, prunedEntries=7946, prunedPages=53,prunedPostingTrees=0, postingPagesDeleted=0, emptyPostingPages=0, numBacktracks=22, isNewBulkDelete=1, numEntryPages=56, numDataPages=0, numVoidPages=0
LOG:  Skipped buffers for the backtrack 21
LOG:  Vacuum[index=19205,vacuumCleanup=1] emptyEntryPages=0, emptyEntries=0, emptyPostingTrees=0, prunedEntries=0, prunedPages=0,prunedPostingTrees=0, postingPagesDeleted=0, emptyPostingPages=0, numBacktracks=0, isNewBulkDelete=1, numEntryPages=3, numDataPages=0, numVoidPages=53
reset client_min_messages;
-- should have no cycleid
SELECT COUNT(*), MIN((entry->>'cycleId')::int4), MAX((entry->>'cycleId')::int4) FROM (SELECT i, documentdb_api_internal.documentdb_rum_page_get_stats(public.get_raw_page('documentdb_data.documents_rum_index_802', i)) entry FROM generate_series(1, 56) i) AS q1
    WHERE (entry->>'cycleId')::int4 > 0;
 count | min | max 
-------+-----+-----
     0 |     |    
(1 row)

-- check the stats (should have 2 entries - one for the leftmost and rightmost).
SELECT documentdb_api_internal.documentdb_rum_get_meta_page_info(public.get_raw_page('documentdb_data.documents_rum_index_802', 0));
                             documentdb_rum_get_meta_page_info                             
-------------------------------------------------------------------------------------------
 {"entries": 2, "dataPages": 0, "entryPages": 3, "totalPages": 57, "pendingHeapTuples": 0}
(1 row)

