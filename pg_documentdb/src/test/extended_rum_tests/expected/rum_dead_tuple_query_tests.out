SET search_path TO documentdb_api_catalog, documentdb_core, public;
SET documentdb.next_collection_id TO 600;
SET documentdb.next_collection_index_id TO 600;
CREATE SCHEMA rum_dead_tuple_test;
-- converts index term bytea to bson with flags
CREATE FUNCTION rum_dead_tuple_test.gin_bson_index_term_to_bson(bytea) 
RETURNS bson
LANGUAGE c
AS '$libdir/pg_documentdb', 'gin_bson_index_term_to_bson';
-- debug function to read index pages
CREATE OR REPLACE FUNCTION rum_dead_tuple_test.documentdb_rum_page_get_entries(page bytea, indexOid Oid)
RETURNS SETOF jsonb
LANGUAGE c
AS '$libdir/pg_documentdb_extended_rum_core', 'documentdb_rum_page_get_entries';
CREATE OR REPLACE FUNCTION rum_dead_tuple_test.documentdb_rum_page_get_data_items(page bytea)
RETURNS SETOF jsonb
LANGUAGE c
AS '$libdir/pg_documentdb_extended_rum_core', 'documentdb_rum_page_get_data_items';
CREATE OR REPLACE FUNCTION rum_dead_tuple_test.documentdb_rum_page_get_stats(page bytea)
RETURNS jsonb
LANGUAGE c
AS '$libdir/pg_documentdb_extended_rum_core', 'documentdb_rum_page_get_stats';
CREATE OR REPLACE FUNCTION rum_dead_tuple_test.documentdb_rum_revive_index_tuples(index_oid oid, dry_run bool)
RETURNS void
LANGUAGE c
AS '$libdir/pg_documentdb_extended_rum_core', 'documentdb_rum_repair_revive_all_pages_and_tuples';
SELECT documentdb_api.drop_collection('pvacuum_db_2', 'p_dead_tup');
 drop_collection 
-----------------
 f
(1 row)

SELECT documentdb_api.create_collection('pvacuum_db_2', 'p_dead_tup');
NOTICE:  creating collection
 create_collection 
-------------------
 t
(1 row)

SELECT collection_id AS vacuum_col FROM documentdb_api_catalog.collections WHERE database_name = 'pvacuum_db_2' AND collection_name = 'p_dead_tup' \gset
-- disable autovacuum to have predicatability
SELECT FORMAT('ALTER TABLE documentdb_data.documents_%s set (autovacuum_enabled = off)', :vacuum_col) \gexec
ALTER TABLE documentdb_data.documents_601 set (autovacuum_enabled = off)
SELECT COUNT(documentdb_api.insert_one('pvacuum_db_2', 'p_dead_tup',  FORMAT('{ "_id": %s, "a": %s }', i, i)::bson)) FROM generate_series(1, 1000) AS i;
 count 
-------
  1000
(1 row)

SELECT documentdb_api_internal.create_indexes_non_concurrently(
    'pvacuum_db_2',
    '{ "createIndexes": "p_dead_tup", "indexes": [ { "key": { "a": 1 }, "name": "a_1", "enableCompositeTerm": true } ] }', TRUE);
                                                                                                   create_indexes_non_concurrently                                                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 { "raw" : { "defaultShard" : { "numIndexesBefore" : { "$numberInt" : "1" }, "numIndexesAfter" : { "$numberInt" : "2" }, "createdCollectionAutomatically" : false, "ok" : { "$numberInt" : "1" } } }, "ok" : { "$numberInt" : "1" } }
(1 row)

\d documentdb_data.documents_601
           Table "documentdb_data.documents_601"
     Column      |  Type  | Collation | Nullable | Default 
-----------------+--------+-----------+----------+---------
 shard_key_value | bigint |           | not null | 
 object_id       | bson   |           | not null | 
 document        | bson   |           | not null | 
Indexes:
    "collection_pk_601" PRIMARY KEY, btree (shard_key_value, object_id)
    "documents_rum_index_602" documentdb_extended_rum (document documentdb_extended_rum_catalog.bson_extended_rum_composite_path_ops (pathspec='[ "a" ]', tl='2691'))
Check constraints:
    "shard_key_value_check" CHECK (shard_key_value = '601'::bigint)

set documentdb.enableExtendedExplainPlans to on;
set documentdb.forceDisableSeqScan to on;
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                             run_explain_and_trim                              
-------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=1000 loops=1)
   indexName: a_1
   isMultiKey: false
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 1000 loops
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 1000)]
   ->  Bitmap Heap Scan on documents_601 collection (actual rows=1000 loops=1)
         Recheck Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
         Heap Blocks: exact=10
         ->  Bitmap Index Scan on a_1 (actual rows=1000 loops=1)
               Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(12 rows)

reset documentdb.forceDisableSeqScan;
SELECT documentdb_api.delete('pvacuum_db_2', '{ "delete": "p_dead_tup", "deletes": [ { "q": { "_id": { "$gte": 10 } }, "limit": 0 } ]}');
                                          delete                                          
------------------------------------------------------------------------------------------
 ("{ ""n"" : { ""$numberInt"" : ""991"" }, ""ok"" : { ""$numberDouble"" : ""1.0"" } }",t)
(1 row)

set documentdb.forceDisableSeqScan to on;
set documentdb.forceDisableSeqScan to on;
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                             run_explain_and_trim                             
------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=9 loops=1)
   indexName: a_1
   isMultiKey: false
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 1000 loops
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 1000)]
   ->  Bitmap Heap Scan on documents_601 collection (actual rows=9 loops=1)
         Recheck Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
         Heap Blocks: exact=10
         ->  Bitmap Index Scan on a_1 (actual rows=1000 loops=1)
               Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(12 rows)

-- vacuum the main table with FREEZE - but skip the index prune (to generate LP_DEAD scenario deterministically)
SELECT FORMAT('VACUUM (FREEZE ON, INDEX_CLEANUP OFF) documentdb_data.documents_%s', :vacuum_col) \gexec
VACUUM (FREEZE ON, INDEX_CLEANUP OFF) documentdb_data.documents_601
-- now enable index dead tuple cleanup & run the query twice.
set documentdb_rum.enable_support_dead_index_items to on;
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=9 loops=1)
   indexName: a_1
   isMultiKey: false
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 1000 loops
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 1000)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=9 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(9 rows)

SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=9 loops=1)
   indexName: a_1
   isMultiKey: false
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 9 loops
   deadEntriesOrPagesSkipped: 991 items
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 9)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=9 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(10 rows)

-- recovers the dead tuple values as is.
set documentdb_rum.enable_support_dead_index_items to off;
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=9 loops=1)
   indexName: a_1
   isMultiKey: false
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 1000 loops
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 1000)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=9 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(9 rows)

-- now insert a document - should resurrect the tuple.
-- first read the tuples & metadata.
SELECT entry->> 'offset' AS offset,
    entry->> 'entryFlags' AS flags,
    rum_dead_tuple_test.gin_bson_index_term_to_bson((entry->>'firstEntry')::bytea) ->> '$' AS index_value
        FROM rum_dead_tuple_test.documentdb_rum_page_get_entries(public.get_raw_page('documentdb_data.documents_rum_index_602', 3), 'documentdb_data.documents_rum_index_602'::regclass) entry
    LIMIT 20;
 offset | flags | index_value 
--------+-------+-------------
 1      | 1     | 1
 2      | 1     | 2
 3      | 1     | 3
 4      | 1     | 4
 5      | 1     | 5
 6      | 1     | 6
 7      | 1     | 7
 8      | 1     | 8
 9      | 1     | 9
 10     | 3     | 10
 11     | 3     | 11
 12     | 3     | 12
 13     | 3     | 13
 14     | 3     | 14
 15     | 3     | 15
 16     | 3     | 16
 17     | 3     | 17
 18     | 3     | 18
 19     | 3     | 19
 20     | 3     | 20
(20 rows)

-- update a single node and write to it. The index term is "revived"
SELECT documentdb_api.insert_one('pvacuum_db_2', 'p_dead_tup',  '{ "_id": -1, "a": 18 }'::bson);
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

-- print index again.
SELECT entry->> 'offset' AS offset,
    entry->> 'entryFlags' AS flags,
    rum_dead_tuple_test.gin_bson_index_term_to_bson((entry->>'firstEntry')::bytea) ->> '$' AS index_value
        FROM rum_dead_tuple_test.documentdb_rum_page_get_entries(public.get_raw_page('documentdb_data.documents_rum_index_602', 3), 'documentdb_data.documents_rum_index_602'::regclass) entry
    LIMIT 20;
 offset | flags | index_value 
--------+-------+-------------
 1      | 1     | 1
 2      | 1     | 2
 3      | 1     | 3
 4      | 1     | 4
 5      | 1     | 5
 6      | 1     | 6
 7      | 1     | 7
 8      | 1     | 8
 9      | 1     | 9
 10     | 3     | 10
 11     | 3     | 11
 12     | 3     | 12
 13     | 3     | 13
 14     | 3     | 14
 15     | 3     | 15
 16     | 3     | 16
 17     | 3     | 17
 18     | 1     | 18
 19     | 3     | 19
 20     | 3     | 20
(20 rows)

-- that row is returned properly but the count of rows is correct.
set documentdb_rum.enable_support_dead_index_items to on;
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                               
---------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=10 loops=1)
   indexName: a_1
   isMultiKey: false
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 10 loops
   deadEntriesOrPagesSkipped: 990 items
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 11)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=10 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(10 rows)

-- repeat with multi-key scenarios with posting lists
SELECT FORMAT('TRUNCATE documentdb_data.documents_%s', :vacuum_col) \gexec
TRUNCATE documentdb_data.documents_601
SELECT COUNT(documentdb_api.insert_one('pvacuum_db_2', 'p_dead_tup',  FORMAT('{ "_id": %s, "a": [ %s, %s, %s ] }', i, i, i * 2, i * 3)::bson)) FROM generate_series(1, 10000) AS i;
 count 
-------
 10000
(1 row)

set documentdb.enableExtendedExplainPlans to on;
set documentdb.forceDisableSeqScan to on;
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=10000 loops=1)
   indexName: a_1
   isMultiKey: true
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 20000 loops
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 30000)]
   ->  Bitmap Heap Scan on documents_601 collection (actual rows=10000 loops=1)
         Recheck Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
         Heap Blocks: exact=114
         ->  Bitmap Index Scan on a_1 (actual rows=30000 loops=1)
               Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(12 rows)

-- here we leave behind index tuples 1 to 10, even numbers and multiples of 3 until 30.
reset documentdb.forceDisableSeqScan;
SELECT documentdb_api.delete('pvacuum_db_2', '{ "delete": "p_dead_tup", "deletes": [ { "q": { "_id": { "$gte": 10 } }, "limit": 0 } ]}');
                                          delete                                           
-------------------------------------------------------------------------------------------
 ("{ ""n"" : { ""$numberInt"" : ""9991"" }, ""ok"" : { ""$numberDouble"" : ""1.0"" } }",t)
(1 row)

set documentdb.forceDisableSeqScan to on;
-- vacuum the main table with FREEZE - but skip the index prune (to generate LP_DEAD scenario deterministically)
SELECT FORMAT('VACUUM (FREEZE ON, INDEX_CLEANUP OFF) documentdb_data.documents_%s', :vacuum_col) \gexec
VACUUM (FREEZE ON, INDEX_CLEANUP OFF) documentdb_data.documents_601
-- now enable index dead tuple cleanup & run the query twice.
set documentdb_rum.enable_support_dead_index_items to on;
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=9 loops=1)
   indexName: a_1
   isMultiKey: true
   indexBounds: ["a": [MinKey, MaxKey]]
   numDuplicates: 20000 entries
   innerScanLoops: 20000 loops
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 30000)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=9 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(10 rows)

-- this will only clean up even more occurrences (since duplicate TID bitmap won't track kill_prior_tuple).
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=9 loops=1)
   indexName: a_1
   isMultiKey: true
   indexBounds: ["a": [MinKey, MaxKey]]
   numDuplicates: 16500 entries
   innerScanLoops: 16581 loops
   deadEntriesOrPagesSkipped: 3419 items
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 26474)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=9 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(11 rows)

-- this will only clean up even more occurrences (since duplicate TID bitmap won't track kill_prior_tuple).
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=9 loops=1)
   indexName: a_1
   isMultiKey: true
   indexBounds: ["a": [MinKey, MaxKey]]
   numDuplicates: 11381 entries
   innerScanLoops: 13166 loops
   deadEntriesOrPagesSkipped: 6834 items
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 21280)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=9 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(11 rows)

-- this will only clean up even more occurrences (since duplicate TID bitmap won't track kill_prior_tuple).
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=9 loops=1)
   indexName: a_1
   isMultiKey: true
   indexBounds: ["a": [MinKey, MaxKey]]
   numDuplicates: 7717 entries
   innerScanLoops: 8158 loops
   deadEntriesOrPagesSkipped: 11842 items
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 14275)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=9 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(11 rows)

-- recovers the dead tuple values as is.
set documentdb_rum.enable_support_dead_index_items to off;
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=9 loops=1)
   indexName: a_1
   isMultiKey: true
   indexBounds: ["a": [MinKey, MaxKey]]
   numDuplicates: 20000 entries
   innerScanLoops: 20000 loops
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 30000)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=9 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(10 rows)

-- now resurrect multiple terms (should resurrect even when flag is off)
set documentdb_rum.enable_support_dead_index_items to off;
-- now insert a document - should resurrect the tuple.
-- first read the tuples & metadata.
SELECT entry->> 'offset' AS offset,
    entry->> 'entryFlags' AS flags,
    rum_dead_tuple_test.gin_bson_index_term_to_bson((entry->>'firstEntry')::bytea) ->> '$' AS index_value
        FROM rum_dead_tuple_test.documentdb_rum_page_get_entries(public.get_raw_page('documentdb_data.documents_rum_index_602', 3),  'documentdb_data.documents_rum_index_602'::regclass) entry
    LIMIT 20;
 offset | flags | index_value 
--------+-------+-------------
 1      | 1     | 
 2      | 1     | 1
 3      | 1     | 2
 4      | 1     | 3
 5      | 1     | 4
 6      | 1     | 5
 7      | 1     | 6
 8      | 1     | 7
 9      | 1     | 8
 10     | 1     | 9
 11     | 1     | 10
 12     | 3     | 11
 13     | 1     | 12
 14     | 3     | 13
 15     | 1     | 14
 16     | 1     | 15
 17     | 1     | 16
 18     | 3     | 17
 19     | 1     | 18
 20     | 3     | 19
(20 rows)

-- update a single node and write to it. The index term is "revived"
SELECT documentdb_api.insert_one('pvacuum_db_2', 'p_dead_tup',  '{ "_id": -1, "a": [ 17, 12, 19 ] }'::bson);
                              insert_one                              
----------------------------------------------------------------------
 { "n" : { "$numberInt" : "1" }, "ok" : { "$numberDouble" : "1.0" } }
(1 row)

-- print index again.
SELECT entry->> 'offset' AS offset,
    entry->> 'entryFlags' AS flags,
    rum_dead_tuple_test.gin_bson_index_term_to_bson((entry->>'firstEntry')::bytea) ->> '$' AS index_value
        FROM rum_dead_tuple_test.documentdb_rum_page_get_entries(public.get_raw_page('documentdb_data.documents_rum_index_602', 3),  'documentdb_data.documents_rum_index_602'::regclass) entry
    LIMIT 20;
 offset | flags | index_value 
--------+-------+-------------
 1      | 1     | 
 2      | 1     | 1
 3      | 1     | 2
 4      | 1     | 3
 5      | 1     | 4
 6      | 1     | 5
 7      | 1     | 6
 8      | 1     | 7
 9      | 1     | 8
 10     | 1     | 9
 11     | 1     | 10
 12     | 3     | 11
 13     | 1     | 12
 14     | 3     | 13
 15     | 1     | 14
 16     | 1     | 15
 17     | 1     | 16
 18     | 1     | 17
 19     | 1     | 18
 20     | 1     | 19
(20 rows)

-- now revive all the tuples using the repair function
SELECT rum_dead_tuple_test.documentdb_rum_revive_index_tuples('documentdb_data.documents_rum_index_602'::regclass::oid, false);
INFO:  Reviving all pages in index with dryRunMode 0
 documentdb_rum_revive_index_tuples 
------------------------------------
 
(1 row)

-- check which entries are dead (should be none)
SELECT entry->> 'offset' AS offset, entry->> 'entryFlags' AS flags
        FROM rum_dead_tuple_test.documentdb_rum_page_get_entries(public.get_raw_page('documentdb_data.documents_rum_index_602', 3),  'documentdb_data.documents_rum_index_602'::regclass) entry
    WHERE entry->> 'entryFlags' != '1' LIMIT 20;
 offset | flags 
--------+-------
(0 rows)

-- now repeat the scenarios above with posting trees.
SELECT FORMAT('TRUNCATE documentdb_data.documents_%s', :vacuum_col) \gexec
TRUNCATE documentdb_data.documents_601
SELECT COUNT(documentdb_api.insert_one('pvacuum_db_2', 'p_dead_tup',  FORMAT('{ "_id": %s, "a": 5 }', i, i)::bson)) FROM generate_series(1, 10000) AS i;
 count 
-------
 10000
(1 row)

SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=10000 loops=1)
   indexName: a_1
   isMultiKey: false
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 1 loops
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 9198)]
   ->  Bitmap Heap Scan on documents_601 collection (actual rows=10000 loops=1)
         Recheck Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
         Heap Blocks: exact=94
         ->  Bitmap Index Scan on a_1 (actual rows=10000 loops=1)
               Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(12 rows)

reset documentdb.forceDisableSeqScan;
SELECT documentdb_api.delete('pvacuum_db_2', '{ "delete": "p_dead_tup", "deletes": [ { "q": { "_id": { "$gte": 10 } }, "limit": 0 } ]}');
                                          delete                                           
-------------------------------------------------------------------------------------------
 ("{ ""n"" : { ""$numberInt"" : ""9991"" }, ""ok"" : { ""$numberDouble"" : ""1.0"" } }",t)
(1 row)

set documentdb.forceDisableSeqScan to on;
-- vacuum the main table with FREEZE - but skip the index prune (to generate LP_DEAD scenario deterministically)
SELECT FORMAT('VACUUM (FREEZE ON, INDEX_CLEANUP OFF) documentdb_data.documents_%s', :vacuum_col) \gexec
VACUUM (FREEZE ON, INDEX_CLEANUP OFF) documentdb_data.documents_601
-- read the entry tree
SELECT entry->> 'offset' AS offset,
    entry ->> 'entryType' AS postingType,
    entry ->> 'tupleTid' AS postingTreeRoot,
    rum_dead_tuple_test.gin_bson_index_term_to_bson((entry->>'firstEntry')::bytea) ->> '$' AS index_value
        FROM rum_dead_tuple_test.documentdb_rum_page_get_entries(public.get_raw_page('documentdb_data.documents_rum_index_602', 1),  'documentdb_data.documents_rum_index_602'::regclass) entry
    LIMIT 20;
 offset | postingtype | postingtreeroot | index_value 
--------+-------------+-----------------+-------------
 1      | postingTree | (2,65535)       | 5
(1 row)

-- read the posting root
SELECT entry FROM rum_dead_tuple_test.documentdb_rum_page_get_data_items(public.get_raw_page('documentdb_data.documents_rum_index_602', 2)) entry OFFSET 1;
                        entry                         
------------------------------------------------------
 {"offset": 1, "itemTid": "(14,35)", "childBlock": 4}
 {"offset": 2, "itemTid": "(28,68)", "childBlock": 3}
 {"offset": 3, "itemTid": "(42,91)", "childBlock": 5}
 {"offset": 4, "itemTid": "(57,11)", "childBlock": 6}
 {"offset": 5, "itemTid": "(71,46)", "childBlock": 7}
 {"offset": 6, "itemTid": "(0,0)", "childBlock": 8}
(6 rows)

WITH r1 AS (SELECT i, rum_dead_tuple_test.documentdb_rum_page_get_stats(public.get_raw_page('documentdb_data.documents_rum_index_602', i)) as entry FROM generate_series(3, 8) i)
SELECT i AS pageId, entry-> 'flagsStr' AS flagsStr, entry-> 'leftLink' AS leftLink, entry->'rightLink' AS rightLink FROM r1 ORDER by i ASC;
 pageid |  flagsstr   | leftlink | rightlink 
--------+-------------+----------+-----------
      3 | "LEAF|DATA" | 4        | 5
      4 | "LEAF|DATA" | null     | 3
      5 | "LEAF|DATA" | 3        | 6
      6 | "LEAF|DATA" | 5        | 7
      7 | "LEAF|DATA" | 6        | 8
      8 | "LEAF|DATA" | 7        | null
(6 rows)

-- query right after delete: estimatedEntryCount shows up at 1000
set documentdb_rum.enable_support_dead_index_items to off;
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=9 loops=1)
   indexName: a_1
   isMultiKey: false
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 1 loops
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 9198)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=9 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(9 rows)

-- now set the GUC and query twice
set documentdb_rum.enable_support_dead_index_items to on;
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=9 loops=1)
   indexName: a_1
   isMultiKey: false
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 1 loops
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 9198)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=9 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(9 rows)

-- now set the GUC and query twice
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=9 loops=1)
   indexName: a_1
   isMultiKey: false
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 1 loops
   deadEntriesOrPagesSkipped: 5 items
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 9198)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=9 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(10 rows)

-- check page metadata
WITH r1 AS (SELECT i, rum_dead_tuple_test.documentdb_rum_page_get_stats(public.get_raw_page('documentdb_data.documents_rum_index_602', i)) as entry FROM generate_series(3, 8) i)
SELECT i AS pageId, entry-> 'flagsStr' AS flagsStr, entry-> 'leftLink' AS leftLink, entry->'rightLink' AS rightLink FROM r1 ORDER by i ASC;
 pageid |             flagsstr             | leftlink | rightlink 
--------+----------------------------------+----------+-----------
      3 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 4        | 5
      4 | "LEAF|DATA"                      | null     | 3
      5 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 3        | 6
      6 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 5        | 7
      7 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 6        | 8
      8 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 7        | null
(6 rows)

WITH r1 AS (SELECT i AS pageId FROM generate_series(3, 8) i)
SELECT pageId, rightQuery.* FROM r1 JOIN LATERAL (
    SELECT COUNT(entry) FROM rum_dead_tuple_test.documentdb_rum_page_get_data_items(public.get_raw_page('documentdb_data.documents_rum_index_602', pageId)) entry
) AS rightQuery ON true ORDER BY pageId ASC;
 pageid | count 
--------+-------
      3 |  1532
      4 |  1534
      5 |  1522
      6 |  1526
      7 |  1534
      8 |  2358
(6 rows)

-- kill the remaining rows
reset documentdb.forceDisableSeqScan;
SELECT documentdb_api.delete('pvacuum_db_2', '{ "delete": "p_dead_tup", "deletes": [ { "q": { "_id": { "$gte": 0 } }, "limit": 0 } ]}');
                                         delete                                         
----------------------------------------------------------------------------------------
 ("{ ""n"" : { ""$numberInt"" : ""9"" }, ""ok"" : { ""$numberDouble"" : ""1.0"" } }",t)
(1 row)

set documentdb.forceDisableSeqScan to on;
SELECT FORMAT('VACUUM (FREEZE ON, INDEX_CLEANUP OFF) documentdb_data.documents_%s', :vacuum_col) \gexec
VACUUM (FREEZE ON, INDEX_CLEANUP OFF) documentdb_data.documents_601
-- now set the GUC and query twice
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                              run_explain_and_trim                              
--------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=0 loops=1)
   indexName: a_1
   isMultiKey: false
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 1 loops
   deadEntriesOrPagesSkipped: 5 items
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 9198)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=0 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(10 rows)

-- check page metadata
WITH r1 AS (SELECT i, rum_dead_tuple_test.documentdb_rum_page_get_stats(public.get_raw_page('documentdb_data.documents_rum_index_602', i)) as entry FROM generate_series(3, 8) i)
SELECT i AS pageId, entry-> 'flagsStr' AS flagsStr, entry-> 'leftLink' AS leftLink, entry->'rightLink' AS rightLink FROM r1 ORDER by i ASC;
 pageid |             flagsstr             | leftlink | rightlink 
--------+----------------------------------+----------+-----------
      3 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 4        | 5
      4 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | null     | 3
      5 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 3        | 6
      6 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 5        | 7
      7 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 6        | 8
      8 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 7        | null
(6 rows)

-- insert rows (to revive data pages)
SELECT COUNT(documentdb_api.insert_one('pvacuum_db_2', 'p_dead_tup',  FORMAT('{ "_id": %s, "a": 5 }', i, i)::bson)) FROM generate_series(-100, -1) AS i;
 count 
-------
   100
(1 row)

WITH r1 AS (SELECT i, rum_dead_tuple_test.documentdb_rum_page_get_stats(public.get_raw_page('documentdb_data.documents_rum_index_602', i)) as entry FROM generate_series(3, 8) i)
SELECT i AS pageId, entry-> 'flagsStr' AS flagsStr, entry-> 'leftLink' AS leftLink, entry->'rightLink' AS rightLink FROM r1 ORDER by i ASC;
 pageid |             flagsstr             | leftlink | rightlink 
--------+----------------------------------+----------+-----------
      3 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 4        | 5
      4 | "LEAF|DATA"                      | null     | 3
      5 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 3        | 6
      6 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 5        | 7
      7 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 6        | 8
      8 | "LEAF|DATA|DATA_PAGE_ENTRY_DEAD" | 7        | null
(6 rows)

WITH r1 AS (SELECT i AS pageId FROM generate_series(3, 8) i)
SELECT pageId, rightQuery.* FROM r1 JOIN LATERAL (
    SELECT COUNT(entry) FROM rum_dead_tuple_test.documentdb_rum_page_get_data_items(public.get_raw_page('documentdb_data.documents_rum_index_602', pageId)) entry
) AS rightQuery ON true ORDER BY pageId ASC;
 pageid | count 
--------+-------
      3 |  1532
      4 |  1634
      5 |  1522
      6 |  1526
      7 |  1534
      8 |  2358
(6 rows)

-- query returns correct rows
SELECT documentdb_test_helpers.run_explain_and_trim(
    $cmd$ EXPLAIN (COSTS OFF, ANALYZE ON, VERBOSE OFF, BUFFERS OFF, SUMMARY OFF, TIMING OFF) SELECT document FROM bson_aggregation_find('pvacuum_db_2', '{ "find": "p_dead_tup", "filter": { "a": { "$exists": true } } }') $cmd$);
                               run_explain_and_trim                               
----------------------------------------------------------------------------------
 Custom Scan (DocumentDBApiExplainQueryScan) (actual rows=100 loops=1)
   indexName: a_1
   isMultiKey: false
   indexBounds: ["a": [MinKey, MaxKey]]
   innerScanLoops: 1 loops
   deadEntriesOrPagesSkipped: 5 items
   scanType: ordered
   scanKeyDetails: key 1: [(isInequality: true, estimatedEntryCount: 9798)]
   ->  Index Scan using a_1 on documents_601 collection (actual rows=100 loops=1)
         Index Cond: (document @>= '{ "a" : { "$minKey" : 1 } }'::bson)
(10 rows)

-- revive and print
SELECT rum_dead_tuple_test.documentdb_rum_revive_index_tuples('documentdb_data.documents_rum_index_602'::regclass::oid, false);
INFO:  Reviving all pages in index with dryRunMode 0
 documentdb_rum_revive_index_tuples 
------------------------------------
 
(1 row)

WITH r1 AS (SELECT i, rum_dead_tuple_test.documentdb_rum_page_get_stats(public.get_raw_page('documentdb_data.documents_rum_index_602', i)) as entry FROM generate_series(3, 8) i)
SELECT i AS pageId, entry-> 'flagsStr' AS flagsStr, entry-> 'leftLink' AS leftLink, entry->'rightLink' AS rightLink FROM r1 ORDER by i ASC;
 pageid |  flagsstr   | leftlink | rightlink 
--------+-------------+----------+-----------
      3 | "LEAF|DATA" | 4        | 5
      4 | "LEAF|DATA" | null     | 3
      5 | "LEAF|DATA" | 3        | 6
      6 | "LEAF|DATA" | 5        | 7
      7 | "LEAF|DATA" | 6        | 8
      8 | "LEAF|DATA" | 7        | null
(6 rows)

